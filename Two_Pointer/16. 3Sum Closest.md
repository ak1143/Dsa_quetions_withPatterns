
---

# **16. 3Sum Closest**

## **Problem**

Given an integer array `nums` and an integer `target`, return the **sum of three integers** such that the sum is **closest to target**.

You may assume **exactly one solution exists**.

---

## **1ï¸âƒ£ Brute Force Approach**

### ğŸ’¡ Idea

* Try **all possible triplets**
* Compute their sum
* Track the minimum absolute difference from `target`

---

### âœ… Code (Brute Force)

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int n = nums.length;
        int closest = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    int sum = nums[i] + nums[j] + nums[k];
                    if (Math.abs(target - sum) < Math.abs(target - closest)) {
                        closest = sum;
                    }
                }
            }
        }
        return closest;
    }
}
```

---

### â± Time Complexity

```
O(nÂ³)
```

### ğŸ’¾ Space Complexity

```
O(1)
```

âŒ Too slow for large inputs

---

## **2ï¸âƒ£ Better Approach (Sorting + Brute Force 2Sum)**

### ğŸ’¡ Idea

* Sort array
* Fix one number
* Try remaining pairs (still nested loops)

---

### â± Time Complexity

```
O(nÂ² log n)
```

âš ï¸ Better than brute force, but still not optimal

---

## **3ï¸âƒ£ Optimal Approach (Sorting + Two Pointers)** âœ…

### ğŸ’¡ Key Insight

* Similar to **3Sum**
* Instead of checking for `0`, we minimize the difference with `target`

---

### âœ… Algorithm

1. Sort the array
2. Fix one element `i`
3. Use two pointers:

   * `left = i + 1`
   * `right = n - 1`
4. Update closest sum
5. Move pointers based on comparison with `target`

---

### âœ… Code (Optimal & Interview-Expected)

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        int closest = nums[0] + nums[1] + nums[2];

        for (int i = 0; i < n - 2; i++) {
            int left = i + 1;
            int right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (Math.abs(target - sum) < Math.abs(target - closest)) {
                    closest = sum;
                }

                if (sum < target) {
                    left++;
                } else if (sum > target) {
                    right--;
                } else {
                    return sum; // exact match
                }
            }
        }
        return closest;
    }
}
```

---

## **â± Time Complexity**

```
O(nÂ²)
```

## **ğŸ’¾ Space Complexity**

```
O(1)
```

---

## **4ï¸âƒ£ Comparison Table**

| Approach            | Time        | Space    | Status |
| ------------------- | ----------- | -------- | ------ |
| Brute Force         | O(nÂ³)       | O(1)     | âŒ      |
| Sort + Nested Loops | O(nÂ² log n) | O(1)     | âš ï¸     |
| Sort + Two Pointer  | **O(nÂ²)**   | **O(1)** | âœ… Best |

---

## **5ï¸âƒ£ Interview One-Liner ğŸ”¥**

> â€œ3Sum Closest is solved by sorting the array and fixing one element while using two pointers to minimize the difference with the target in O(nÂ²) time.â€

---

## **6ï¸âƒ£ Key Interview Notes**

* Similar to 3Sum, but no duplicate handling required
* Return sum, not indices or triplets
* Early return if exact match found
* Sorting enables two-pointer optimization

---
