Below are **concise, interview-ready notes** for

---

# 236. Lowest Common Ancestor of a Binary Tree

---

## ğŸ“Œ Problem Summary

Given a **binary tree** and two nodes `p` and `q`, find their **Lowest Common Ancestor (LCA)**.

> **LCA** is the **lowest (deepest) node** that has **both `p` and `q` as descendants**
> *(a node can be a descendant of itself)*

---

## ğŸ§  Key Observations

* Tree is **NOT a BST**
* Nodes are **unique**
* Both `p` and `q` **exist in the tree**
* We must search **both subtrees**

---

## ğŸŒ³ Visual Example

### Example 2

```
        3
       / \
      5   1
     / \
    6   2
       / \
      7   4
```

**p = 5, q = 4**

â¡ LCA = **5**
(because a node can be an ancestor of itself)

---

## âœ… Approach: DFS / Postorder Traversal

### ğŸ”¹ Why Postorder?

* We need info from **left & right subtrees first**
* Then decide at current node

---

## ğŸ” Algorithm Steps

1. If `root == null` â†’ return `null`
2. If `root == p` or `root == q` â†’ return `root`
3. Recurse on:

   * left subtree
   * right subtree
4. If **both sides return non-null** â†’ current node is LCA
5. Else return the **non-null side**

---

## ğŸ’» Java Implementation (Your Code)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        if (root == null) return null;

        if (root == p || root == q) return root;

        TreeNode leftN = lowestCommonAncestor(root.left, p, q);
        TreeNode rightN = lowestCommonAncestor(root.right, p, q);

        if (leftN != null && rightN != null) return root;

        if (leftN != null) return leftN;

        return rightN;
    }
}
```

---

## â± Complexity Analysis

| Metric           | Value                      |
| ---------------- | -------------------------- |
| Time Complexity  | **O(N)**                   |
| Space Complexity | **O(H)** (recursion stack) |
| Traversal        | DFS (Postorder)            |

`H` = height of tree

---

## ğŸ¯ Interview One-Liner

> â€œWe use postorder DFS. If both left and right subtrees return non-null, the current node is the LCA. Otherwise, we propagate the non-null result upward.â€

---

## ğŸ§ª Edge Cases Covered

* One node is ancestor of the other
* Root itself is LCA
* Nodes in different subtrees
* Deep unbalanced tree

---

## ğŸ†š Binary Tree vs BST (Interview Tip)

| Tree Type   | Approach                |
| ----------- | ----------------------- |
| Binary Tree | Full DFS                |
| BST         | Use ordering (`<`, `>`) |

---