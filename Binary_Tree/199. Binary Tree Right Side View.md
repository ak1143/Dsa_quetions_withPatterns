
---

# 199. Binary Tree Right Side View

## ðŸ“Œ Problem Statement

Given the root of a binary tree, imagine yourself standing on the **right side** of it.
Return the values of the nodes visible from **top to bottom**.

---

## ðŸŒ³ Visual Representation (Input)

### Example

**Input:**
`root = [1,2,3,null,5,null,4]`

```
        1
       / \
      2   3
       \    \
        5    4
```

### ðŸ‘‰ Right Side View

From the right side, we see:

```
Level 0 â†’ 1
Level 1 â†’ 3
Level 2 â†’ 4
```

âœ… **Output:** `[1, 3, 4]`

---

## ðŸ§  Key Observation

* We need **one node per level**
* Specifically, the **rightmost node**
* Level Order Traversal (BFS) naturally processes the tree **level by level**

---

## âœ… Approach 1: BFS â€“ Capture Last Node of Each Level

### ðŸ”¹ Idea

* Use a queue for level-order traversal
* For each level:

  * Keep updating a `node` variable
  * After the level finishes, `node` holds the **rightmost element**

### ðŸ”¹ Why it Works

* Queue processes nodes left â†’ right
* The **last polled node** in a level is the rightmost one

### ðŸ”¹ Code

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {

        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {

            int n = queue.size();
            TreeNode node = null;

            while (n > 0) {
                node = queue.poll();

                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);

                n--;
            }

            result.add(node.val);
        }

        return result;
    }
}
```

---

## âœ… Approach 2: BFS â€“ Use Index to Detect Rightmost Node

### ðŸ”¹ Idea

* Process nodes level by level
* Use a `for` loop
* When `i == levelSize - 1`, that node is the **rightmost**

### ðŸ”¹ Why it Works

* Level size is known before traversal
* The last index corresponds to the rightmost node

### ðŸ”¹ Code

```java
// BFS Approach: 

class Solution {
    public List<Integer> rightSideView(TreeNode root) {

        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {

            int levelSize = queue.size();

            for (int i = 0; i < levelSize; i++) {
                TreeNode curr = queue.poll();

                if (i == levelSize - 1) {
                    result.add(curr.val);
                }

                if (curr.left != null) queue.offer(curr.left);
                if (curr.right != null) queue.offer(curr.right);
            }
        }

        return result;
    }
}
```

---

## â± Complexity Analysis (Both Approaches)

| Metric           | Value             |
| ---------------- | ----------------- |
| Time Complexity  | **O(N)**          |
| Space Complexity | **O(N)** (queue)  |
| Traversal Type   | Level Order (BFS) |

```java
// DFS Approach

class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if(root==null) return result;

        return helperFun(1,root,result);
    }
    public List<Integer> helperFun(int level,TreeNode node,List<Integer> result){
        if(node==null) return result;
        if(result.size()<level){
            result.add(node.val);
        }
        helperFun(level+1,node.right,result);
        helperFun(level+1,node.left,result);
        return result;
    }
}
```

---

