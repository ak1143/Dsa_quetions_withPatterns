
---

# 105. Construct Binary Tree from Preorder and Inorder Traversal

---

## ğŸ“Œ Problem Statement

You are given:

* `preorder[]` â†’ **Root â†’ Left â†’ Right**
* `inorder[]` â†’ **Left â†’ Root â†’ Right**

Construct and return the **original binary tree**.

---

## ğŸ” Key Observations (VERY IMPORTANT)

1. **First element of preorder is always the root**
2. In inorder:

   * Elements **left of root** â†’ left subtree
   * Elements **right of root** â†’ right subtree
3. Preorder index moves **sequentially** as nodes are created

---

## ğŸŒ³ Visual Example

### Input

```
preorder = [3, 9, 20, 15, 7]
inorder  = [9, 3, 15, 20, 7]
```

### Tree Structure

```
        3
       / \
      9   20
          / \
         15  7
```

---

## âŒ Issues in Your Original Code (Interviewers WILL notice)

* Returning nothing from `helper`
* `TreeNode node = pre[ind];` âŒ (pre[ind] is int, not TreeNode)
* Wrong recursion order (right before left)
* Incorrect base conditions
* Searching inorder every time â†’ O(NÂ²)

---

## âœ… Correct & Optimized Approach (O(N))

### ğŸ”¹ Strategy

* Use a **global preorder index**
* Use a **HashMap** to store inorder indices (fast lookup)
* Build tree recursively:

  * Pick root from preorder
  * Split inorder into left & right
  * Recurse left â†’ recurse right

---

## âœ… Interview-Ready Java Implementation

```java
class Solution {

    int preIndex = 0;
    HashMap<Integer, Integer> inorderMap = new HashMap<>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {

        // Store inorder indices for O(1) lookup
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }

        return helper(preorder, 0, inorder.length - 1);
    }

    private TreeNode helper(int[] preorder, int start, int end) {

        // Base case
        if (start > end) return null;

        // Create root from preorder
        int rootVal = preorder[preIndex++];
        TreeNode root = new TreeNode(rootVal);

        // Find root position in inorder
        int index = inorderMap.get(rootVal);

        // Build left and right subtrees
        root.left = helper(preorder, start, index - 1);
        root.right = helper(preorder, index + 1, end);

        return root;
    }
}
```

---

## â± Time & Space Complexity

| Metric           | Value              |
| ---------------- | ------------------ |
| Time Complexity  | **O(N)**           |
| Space Complexity | **O(N)**           |
| Traversal Used   | Preorder + Inorder |
| Technique        | Divide & Conquer   |

---

## ğŸ§  Dry Run (Quick)

```
Preorder index moves: 3 â†’ 9 â†’ 20 â†’ 15 â†’ 7
Each value splits inorder into left/right subtree
Recursive construction rebuilds the tree
```
---

# 105. Construct Binary Tree from Preorder and Inorder Traversal

### âœ… Approach 2: Recursive Construction (Without HashMap)

---

## ğŸ§  Core Idea

* **Preorder** tells us the **root first**
* **Inorder** tells us how to split **left and right subtrees**
* We move through preorder using a **global index**

---

## ğŸ” Traversal Properties

| Traversal | Order               |
| --------- | ------------------- |
| Preorder  | Root â†’ Left â†’ Right |
| Inorder   | Left â†’ Root â†’ Right |

---

## ğŸŒ³ Visual Example

### Input

```
Preorder = [3, 9, 20, 15, 7]
Inorder  = [9, 3, 15, 20, 7]
```

### Step-by-Step Construction

```
Preorder index â†’ 3  â†’ root
Inorder split â†’ [9] | 3 | [15,20,7]

Left subtree root â†’ 9
Right subtree root â†’ 20
```

### Final Tree

```
        3
       / \
      9   20
          / \
         15  7
```

---

## âœ… Code (Second Approach â€“ Linear Search)

```java
class Solution {

    int preIndex = 0;

    public TreeNode buildTree(int[] pre, int[] in) {
        return helper(pre, in, 0, pre.length - 1);
    }

    TreeNode helper(int[] pre, int[] in, int start, int end) {

        // Base case
        if (start > end) return null;

        // Pick root from preorder
        int nodeVal = pre[preIndex++];
        TreeNode node = new TreeNode(nodeVal);

        // Find root index in inorder
        int ind = -1;
        for (int i = start; i <= end; i++) {
            if (in[i] == nodeVal) {
                ind = i;
                break;
            }
        }

        // Build left and right subtree
        node.left = helper(pre, in, start, ind - 1);
        node.right = helper(pre, in, ind + 1, end);

        return node;
    }
}
```

---

## â± Time & Space Complexity

| Metric           | Value                                |
| ---------------- | ------------------------------------ |
| Time Complexity  | **O(NÂ²)** (linear search in inorder) |
| Space Complexity | **O(N)** (recursion stack)           |
| Approach Type    | DFS + Divide & Conquer               |

---

## ğŸ“Œ When to Use This Approach

âœ… When:

* HashMap is **not allowed**
* Constraints are **small**
* You want a **simple & intuitive solution**

âŒ Avoid when:

* Input size is large (3000+)
* Performance matters â†’ prefer **HashMap approach**

---

## ğŸ¯ Interview One-Liner

> â€œWe pick the root from preorder and locate it in inorder to split left and right subtrees. A global preorder index ensures correct node construction.â€

---

## ğŸ†š Comparison with Approach 1

| Feature              | With HashMap | Without HashMap |
| -------------------- | ------------ | --------------- |
| Time                 | O(N)         | O(NÂ²)           |
| Extra Space          | HashMap      | None            |
| Interview Preference | â­â­â­â­         | â­â­â­             |

---