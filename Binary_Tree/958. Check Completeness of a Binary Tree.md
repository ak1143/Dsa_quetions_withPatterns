
---

# 958. Check Completeness of a Binary Tree

---

## ğŸ“Œ Problem Statement

Given the root of a binary tree, determine whether it is a **complete binary tree**.

### Definition

A binary tree is **complete** if:

1. Every level, except possibly the last, is **completely filled**
2. All nodes in the **last level are as far left as possible**
3. A node **cannot have a right child without a left child**

---

## ğŸŒ³ Visual Examples

### âœ… Example 1 (Complete)

```
        1
       / \
      2   3
     / \  /
    4  5 6
```

âœ” Output: `true`

---

### âŒ Example 2 (Not Complete)

```
        1
       / \
      2   3
     / \   \
    4  5    7   âŒ
```

âœ” Output: `false`
(Node `7` is not left-aligned)

---

## ğŸ§  Key Insight

Completeness depends on **node positions**, not heights.

ğŸ‘‰ **Level Order Traversal (BFS)** is the correct approach.

---

## âœ… Correct Algorithm (BFS)

### Steps:

1. Use a queue for level order traversal
2. Once a `null` node is seen:

   * All following nodes **must also be null**
3. If a non-null node appears after a null â†’ âŒ not complete

---

## ğŸ’» Java Solution (Interview-Standard)

```java
class Solution {
    public boolean isCompleteTree(TreeNode root) {

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        boolean seenNull = false;

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();

            if (node == null) {
                seenNull = true;
            } else {
                if (seenNull) return false;

                queue.offer(node.left);
                queue.offer(node.right);
            }
        }

        return true;
    }
}
```

---

## â± Complexity Analysis

| Metric           | Value             |
| ---------------- | ----------------- |
| Time Complexity  | **O(N)**          |
| Space Complexity | **O(N)**          |
| Traversal        | Level Order (BFS) |

---

## ğŸ¯ Interview One-Liner

> â€œDuring level-order traversal, once a null node appears, all subsequent nodes must be null for the tree to be complete.â€

---

## ğŸ†š Tree Type Clarification (Often Asked)

| Type     | Rule                     |
| -------- | ------------------------ |
| Complete | Last level left-aligned  |
| Full     | 0 or 2 children only     |
| Perfect  | All leaves at same level |

---
Good ğŸ‘
This is the **SECOND CORRECT approach** for
**958. Check Completeness of a Binary Tree** â€” the **DFS + Indexing method**.

Below are **interview-ready notes**, **clean explanation**, and **where this approach fits**.

---

# ğŸ”¹ Approach 2: DFS + Indexing (Your Code)

---

## ğŸ§  Core Idea

* Assign **indices** to nodes as if the tree were stored in an array (heap-style)
* Root index = `1`
* Left child = `2 * i`
* Right child = `2 * i + 1`

ğŸ‘‰ In a **complete tree**, node indices will be **â‰¤ total number of nodes**

---

## ğŸŒ³ Visualization

```
Index mapping:

        1(1)
       /   \
    2(2)   3(3)
    /
  4(4)
```

âœ” Indices are continuous â†’ **Complete**

---

### âŒ Incomplete Example

```
        1(1)
       /   \
    2(2)   3(3)
       \
        5(5)
```

âŒ Index 4 missing but 5 exists â†’ **Not Complete**

---

## âœ… Algorithm Steps

### Step 1: Count total nodes

```java
totalNodes = CountNodes(root)
```

### Step 2: DFS with index validation

* If index `i > totalNodes` â†’ âŒ not complete
* Recursively check left & right

---

## ğŸ’» Java Implementation (Your Approach)

```java
class Solution {
    public boolean isCompleteTree(TreeNode root) {

        int totalNodes = countNodes(root);
        return dfs(root, 1, totalNodes);
    }

    int countNodes(TreeNode node) {
        if (node == null) return 0;
        return 1 + countNodes(node.left) + countNodes(node.right);
    }

    boolean dfs(TreeNode root, int i, int totalNodes) {
        if (root == null) return true;

        if (i > totalNodes) return false;

        return dfs(root.left, 2 * i, totalNodes)
            && dfs(root.right, 2 * i + 1, totalNodes);
    }
}
```

---

## â± Complexity Analysis

| Metric           | Value                      |
| ---------------- | -------------------------- |
| Time Complexity  | **O(N)**                   |
| Space Complexity | **O(H)** (recursion stack) |
| Traversal        | DFS                        |
| Technique        | Index Mapping              |

---

## ğŸ†š BFS vs DFS Indexing

| Feature              | BFS   | DFS Index |
| -------------------- | ----- | --------- |
| Simplicity           | â­â­â­â­  | â­â­â­       |
| Interview Preference | â­â­â­â­â­ | â­â­â­â­      |
| Uses Queue           | Yes   | No        |
| Uses Index           | No    | Yes       |

---

## ğŸ¯ Interview One-Liners

* **BFS:**

  > â€œAfter the first null in level order traversal, no non-null nodes should appear.â€

* **DFS Indexing:**

  > â€œIn a complete binary tree, heap-style indices must not exceed total node count.â€

---



