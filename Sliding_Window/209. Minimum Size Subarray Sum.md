I‚Äôll explain:

1. **Brute force (O(n¬≤))**
2. **Optimal sliding window (O(n))**
3. **Follow-up solution: O(n log n)**
4. **Time & space analysis**
5. **When to use which**

---

## 1Ô∏è‚É£ Brute Force Solution ‚Äî O(n¬≤)

### Idea

* Try **all subarrays**
* Keep adding elements until sum ‚â• target
* Track minimum length

### Code (Java)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int minLen = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum >= target) {
                    minLen = Math.min(minLen, j - i + 1);
                    break;
                }
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

### Complexity

* **Time:** `O(n¬≤)`
* **Space:** `O(1)`
* ‚ùå Too slow for large input

---

## 2Ô∏è‚É£ Optimal Sliding Window ‚Äî O(n) ‚úÖ (Best Solution)

### Why it works

* All numbers are **positive**
* Expanding window increases sum
* Shrinking window decreases sum

### Algorithm

* Expand right pointer (`j`)
* When sum ‚â• target ‚Üí shrink from left (`i`)
* Keep updating minimum length

### Code (Java)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int minLen = Integer.MAX_VALUE;
        int sum = 0;
        int i = 0;

        for (int j = 0; j < nums.length; j++) {
            sum += nums[j];

            while (sum >= target) {
                minLen = Math.min(minLen, j - i + 1);
                sum -= nums[i];
                i++;
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

### Complexity

* **Time:** `O(n)`
* **Space:** `O(1)`

### Interview Line

> ‚ÄúEach pointer moves at most n times, so total time is linear.‚Äù

---

## 3Ô∏è‚É£ Follow-Up Solution ‚Äî O(n log n)

### Idea

Use **Prefix Sum + Binary Search**

### Steps

1. Build prefix sum array:

   ```
   prefix[i] = sum of first i elements
   ```
2. For each `i`, find smallest `j` such that:

   ```
   prefix[j] - prefix[i] >= target
   ```
3. Use **binary search** for `j`

---

### Code (Java)

```java
import java.util.*;

class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int[] prefix = new int[n + 1];

        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }

        int minLen = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int required = target + prefix[i];
            int j = Arrays.binarySearch(prefix, required);

            if (j < 0) j = -j - 1;
            if (j <= n) {
                minLen = Math.min(minLen, j - i);
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

### Complexity

* **Time:** `O(n log n)`
* **Space:** `O(n)`

---

## 4Ô∏è‚É£ Comparison Table

| Approach               | Time       | Space    | Use Case      |
| ---------------------- | ---------- | -------- | ------------- |
| Brute Force            | O(n¬≤)      | O(1)     | Learning only |
| Sliding Window         | **O(n)**   | **O(1)** | ‚úÖ Best        |
| Prefix + Binary Search | O(n log n) | O(n)     | Follow-up     |

---

## 5Ô∏è‚É£ Key Interview Takeaways üî•

* Sliding window works **only because all numbers are positive**
* If negative numbers exist ‚Üí sliding window **fails**
* Follow-up tests your **prefix sum + binary search** knowledge

---
