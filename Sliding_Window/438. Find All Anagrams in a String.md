---

# 438. Find All Anagrams in a String

---

## 1ï¸âƒ£ Brute Force Approach (Very Basic)

### ğŸ’¡ Idea

* Generate **all substrings of `s`** of length `p.length()`
* For each substring:

  * Check if it is an **anagram** of `p`
* If yes â†’ store starting index

---

### ğŸ” How to Check Anagram (Brute)

* Sort both strings and compare
  **OR**
* Count character frequencies and compare

---

### âœ… Brute Force Code (Sorting)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int m = p.length();

        char[] pArr = p.toCharArray();
        Arrays.sort(pArr);
        String sortedP = new String(pArr);

        for (int i = 0; i <= s.length() - m; i++) {
            String sub = s.substring(i, i + m);
            char[] subArr = sub.toCharArray();
            Arrays.sort(subArr);

            if (sortedP.equals(new String(subArr))) {
                res.add(i);
            }
        }
        return res;
    }
}
```

---

### â± Time Complexity

* Substrings: `O(n)`
* Sorting each substring: `O(m log m)`

```
O(n Ã— m log m)
```

---

### ğŸ’¾ Space Complexity

* Sorting arrays: `O(m)`

---

âŒ **Very slow â€” will TLE**

---

## 2ï¸âƒ£ Better Brute Force (Frequency Count)

### ğŸ’¡ Idea

* Instead of sorting, compare **frequency arrays**
* Still recompute frequency for every substring

---

### âœ… Code

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int n = s.length(), m = p.length();

        int[] pCount = new int[26];
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }

        for (int i = 0; i <= n - m; i++) {
            int[] sCount = new int[26];
            for (int j = i; j < i + m; j++) {
                sCount[s.charAt(j) - 'a']++;
            }

            if (Arrays.equals(pCount, sCount)) {
                res.add(i);
            }
        }
        return res;
    }
}
```

---

### â± Time Complexity

```
O(n Ã— m)
```

### ğŸ’¾ Space Complexity

```
O(26) â†’ O(1)
```

---

âš  Still inefficient for large input

---

## 3ï¸âƒ£ Optimal Approach (Sliding Window) âœ…

### ğŸ’¡ Key Observations

* Window size is fixed â†’ `p.length()`
* Use one frequency array
* Slide window by:

  * Removing left character
  * Adding right character

---

### âœ… Optimal Code

```java
class Solution {

    private boolean allZero(int[] arr) {
        for (int x : arr) {
            if (x != 0) return false;
        }
        return true;
    }

    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int[] count = new int[26];

        for (char c : p.toCharArray()) {
            count[c - 'a']++;
        }

        int i = 0;
        for (int j = 0; j < s.length(); j++) {
            count[s.charAt(j) - 'a']--;

            if (j - i + 1 == p.length()) {
                if (allZero(count)) {
                    res.add(i);
                }
                count[s.charAt(i) - 'a']++;
                i++;
            }
        }
        return res;
    }
}
```

---

### â± Time Complexity

```
O(n)
```

### ğŸ’¾ Space Complexity

```
O(1)
```

---

## 4ï¸âƒ£ Optimized Sliding Window (No allZero) ğŸ”¥

### ğŸ’¡ Improvement

* Maintain a `matches` count instead of scanning 26 chars

---

### âœ… Code

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int[] count = new int[26];

        for (char c : p.toCharArray()) {
            count[c - 'a']++;
        }

        int left = 0, right = 0, needed = p.length();

        while (right < s.length()) {
            if (count[s.charAt(right) - 'a']-- > 0) {
                needed--;
            }
            right++;

            if (needed == 0) res.add(left);

            if (right - left == p.length()) {
                if (count[s.charAt(left) - 'a']++ >= 0) {
                    needed++;
                }
                left++;
            }
        }
        return res;
    }
}
```

---

### â± Time Complexity

```
O(n)
```

### ğŸ’¾ Space Complexity

```
O(1)
```

---

## ğŸ“Š Comparison Table

| Approach         | Time         | Space | Status |
| ---------------- | ------------ | ----- | ------ |
| Brute (sorting)  | O(nÂ·mÂ·log m) | O(m)  | âŒ      |
| Brute (freq)     | O(nÂ·m)       | O(1)  | âŒ      |
| Sliding Window   | O(n)         | O(1)  | âœ…      |
| Optimized Window | O(n)         | O(1)  | â­ Best |

---

