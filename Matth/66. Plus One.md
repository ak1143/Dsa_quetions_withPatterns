
---

## ğŸ“Œ Problem: Plus One (Java)

You are given an array of digits representing a non-negative integer. Each digit is stored such that the most significant digit is at index `0`. The task is to add **1** to the number and return the resulting digit array.

---

## âœ… Approach 1: Optimized Carry Propagation (Recommended)

This approach simulates **manual addition** starting from the last digit. We traverse the array from right to left. If a digit is less than `9`, we increment it and return the array immediately because no carry is generated. If the digit is `9`, we set it to `0` and continue moving left to propagate the carry.

If the loop finishes, it means **all digits were 9**, so the result needs one extra digit. In that case, we create a new array of size `n + 1`, set the first digit to `1`, and return it.

This approach is preferred in interviews because it is **short, efficient, and uses a single loop**.

### Code

```java
class Solution {
    public int[] plusOne(int[] digits) {

        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                digits[i]++;
                return digits;
            }
            digits[i] = 0;
        }

        int[] result = new int[digits.length + 1];
        result[0] = 1;
        return result;
    }
}
```

### Complexity

* **Time:** `O(n)`
* **Space:** `O(1)` (only `O(n)` when array expands)

---

## âœ… Approach 2: Explicit Carry Handling with Full Checks

This approach breaks the logic into clear steps. First, we check if the last digit is not `9`. If so, we simply increment and return. Next, we check if all digits are `9`. If yes, we create a new array with a leading `1`.

If neither case applies, we explicitly propagate the carry by converting trailing `9`s to `0` and incrementing the first non-9 digit from the right.

This approach is more **verbose**, but some interviewers like it because it clearly shows **decision making and edge-case handling**.

### Code

```java
class Solution {
    public int[] plusOne(int[] digits) {

        int n = digits.length - 1;

        if (digits[n] != 9) {
            digits[n]++;
            return digits;
        }

        boolean allNine = true;
        for (int d : digits) {
            if (d != 9) {
                allNine = false;
                break;
            }
        }

        if (allNine) {
            int[] result = new int[digits.length + 1];
            result[0] = 1;
            return result;
        }

        int i = n;
        while (digits[i] == 9) {
            digits[i] = 0;
            i--;
        }
        digits[i]++;
        return digits;
    }
}
```

### Complexity

* **Time:** `O(n)`
* **Space:** `O(n)` (extra checks + array creation)

---

## ğŸ” Comparison (Interview Perspective)

| Aspect               | Approach 1   | Approach 2            |
| -------------------- | ------------ | --------------------- |
| Code length          | Short        | Longer                |
| Loops                | 1            | Multiple              |
| Readability          | High         | Moderate              |
| Interview preference | â­â­â­â­â­        | â­â­â­                   |
| Best for             | Clean coding | Step-wise explanation |

---

## ğŸ¯ Interview One-Line Summary

> â€œI solve this by simulating addition from the last digit, handling carry properly, and creating a new array only when all digits are 9.â€

---

