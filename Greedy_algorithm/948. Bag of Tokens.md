
---

# **948. Bag of Tokens**

---

## ‚ùì Question

You are given an integer array `tokens` where `tokens[i]` represents the power value of the `i·µó ∞` token, and an integer `power`.

You may play tokens in **two ways**:

1. **Face Up**

   * If `power >= tokens[i]`
   * Lose `tokens[i]` power
   * Gain `+1 score`

2. **Face Down**

   * If `score >= 1`
   * Gain `tokens[i]` power
   * Lose `-1 score`

Each token can be used **at most once**.

### üéØ Goal

Return the **maximum score** you can achieve.

---

## ‚úÖ Corrected Answer (Java Code)

```java
class Solution {
    public int bagOfTokensScore(int[] tokens, int power) {

        Arrays.sort(tokens);

        int i = 0;
        int j = tokens.length - 1;

        int score = 0;
        int maxScore = 0;

        while (i <= j) {

            // Play token face up (gain score)
            if (power >= tokens[i]) {
                power -= tokens[i];
                score++;
                i++;
                maxScore = Math.max(maxScore, score);
            }
            // Play token face down (gain power)
            else if (score >= 1) {
                score--;
                power += tokens[j];
                j--;
            }
            // No valid move left
            else {
                break;
            }
        }
        return maxScore;
    }
}
```

---

## üß† Best Approach

### **Greedy + Two Pointers**

---

### üîë Key Idea

* **Always use the smallest token** to gain score
* **Use the largest token** only when you need more power
* Sorting allows efficient decisions using two pointers

---

### üìç Strategy

1. **Sort the tokens**
2. Maintain two pointers:

   * `i` ‚Üí smallest token
   * `j` ‚Üí largest token
3. Repeat until no move is possible:

   * If enough power ‚Üí take smallest token (gain score)
   * Else if score ‚â• 1 ‚Üí trade largest token (gain power)
   * Else ‚Üí stop

---

### üìä Why This Is Optimal

| Action                   | Reason                     |
| ------------------------ | -------------------------- |
| Smallest token for score | Costs minimum power        |
| Largest token for power  | Restores maximum power     |
| Greedy choice            | Leaves best future options |

---

### ‚è± Complexity

| Metric           | Value          |
| ---------------- | -------------- |
| Time Complexity  | **O(N log N)** |
| Space Complexity | **O(1)**       |
| Technique        | Greedy         |

---